(()=>{var F=computeScores=({testee:M,session:O,answers:x,specs:l})=>{let v=n=>Object.values(n).sort((t,s)=>t.itemId-s.itemId).map(t=>t.answerValue),I=(n,t)=>{let s=n.map(o=>o-1),e=t.filter((o,r)=>s.includes(r));return{componentAnswers:e.filter(o=>o.length>0),componentOmissions:e.filter(o=>o.length===0)||[]}},S=(n,t,s=e=>e)=>{if(n.length===0)return{componentScore:null,componentOmissions:null,componentMin:null,componentMax:null};let{componentAnswers:e,componentOmissions:o}=I(n,t),r=e.flat(1/0).map(a=>s(Number(a))),m=r.reduce((a,d)=>a+=d,0),{0:i,[e.length-1]:u}=r.sort();return{componentRawScore:m,componentOmissions:o.length,componentMin:i,componentMax:u}},N=(n,t,s,e,o)=>{let r=s.norms.getNorms,m=eval?.(`"use strict";${r};fn(${JSON.stringify({...e,...o})},"${n}")`),i=s.norms[m];return eval?.(`"use strict";${i};fn(${JSON.stringify(t)})`)},p={},g=v(x);for(let[n,{name:t,straightItems:s,reversedItems:e}]of Object.entries(l.scales)){let{componentRawScore:o,componentOmissions:r,componentMin:m,componentMax:i}=S(s,g),u=c=>l.likert.max+l.likert.min-c,{componentRawScore:a,componentOmissions:d,componentMin:A,componentMax:b}=S(e,g,u),f=(r||0)+(d||0),w=(o||0)+(a||0),$=Number((w/(s.length+e.length-f)).toFixed(2)),R=[m,A].filter(c=>c||c===0).sort().at(0),V=[i,b].filter(c=>c||c===0).sort().at(-1),h={omissions:f,rawScore:w,meanScore:$,minScore:R,maxScore:V},y=N(n,h,l,M,O);p={...p,[n]:{scaleId:n,name:t,...h,standardScore:y}}}return p};})();
